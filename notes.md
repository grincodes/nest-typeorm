npm install --save @nestjs/typeorm typeorm mysql2

In defining TypeOrmModules dont use synchronize
synchronize: true should not be used in production

Once this is done, the TypeORM DataSource and EntityManager objects will be available to inject across the entire project (without needing to import any modules)


# Entity Manager
Using EntityManager you can manage (insert, update, delete, load, etc.) any entity. EntityManager is just like a collection of all entity repositories in a single place.

`import { DataSource } from "typeorm"
import { User } from "./entity/User"

const myDataSource = new DataSource(/*...*/)
const user = await myDataSource.manager.findOneBy(User, {
    id: 1,
})
user.name = "Umed"
await myDataSource.manager.save(user)`

# Repository TypeOrm
Repository is just like EntityManager but its operations are limited to a concrete entity. You can access the repository via EntityManager.
`import { User } from "./entity/User"

const userRepository = dataSource.getRepository(User)
const user = await userRepository.findOneBy({
    id: 1,
})
user.name = "Umed"
await userRepository.save(user)`

There are 3 types of repositories:

Repository - Regular repository for any entity.
TreeRepository - Repository, extensions of Repository used for tree-entities (like entities marked with @Tree decorator). Has special methods to work with tree structures.
MongoRepository - Repository with special functions used only with MongoDB.


# Repository pattern
TypeORM supports the repository design pattern, so each entity has its own repository. These repositories can be obtained from the database data source.

Repository can be created from an Entity/Schema in typeOrm
to get arepository we use the @InjectRepository()

Eg.
`@Injectable()
export UserService {
constructor(@InjectRepository(UserEntity) private userRepo : Repository<UserEntity>)
}
`


# Exporting repository 
If you want to use the repository outside of the module which imports TypeOrmModule.forFeature, you'll need to re-export the providers generated by it. You can do this by exporting the whole module, like this:

`
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  exports: [TypeOrmModule]
})
export class UsersModule {}
`

Now if we import UsersModule in AuthModule, we can use @InjectRepository(User) in the providers of the latter module.

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  controllers: [AuthController]
})
export class AuthModule {}


# Relationships

  @OneToOne(() => Photo) /   @OneToOne(type => Photo)
  @OneToMany(type => Photo, photo => photo.user)

  adding a second parameter to the Relatinship decorator makes is bi-directional.
  bi-directional meanas that both tables are aware of the relationship

  @OneToMany(type => Photo, photo => photo.user)
  photos: Photo[];


   Relations can be unidirectional or bidirectional. Only one side of relational can be owning. Using @JoinColumn decorator is required on the owner side of the relationship.


# Auto Load Entities
Manually adding entities to the entities array of the data source options can be tedious. In addition, referencing entities from the root module breaks application domain boundaries and causes leaking implementation details to other parts of the application. To address this issue, an alternative solution is provided. To automatically load entities, set the autoLoadEntities property of the configuration object (passed into the forRoot() method) to true, as shown below:

`@Module({
  imports: [
    TypeOrmModule.forRoot({
      ...
      autoLoadEntities: true,
    }),
  ],
})`


# Transactions

There are various ways to implement a transaction in TypeOrm based on your usecase
but the most userd and recommended is Using QueryRunner.

There are many different strategies to handle [TypeORM transactions](https://typeorm.io/#/transactions). We recommend using the QueryRunner class because it gives full control over the transaction.


# Transaction Using Query Runner

- First we need to inject the DataSource into a class the normal way

`@Injectable()
    export class UsersService {
    constructor(private dataSource: DataSource) {}
    }`


- Now, we can use this object to create a transaction.


`async createMany(users: User[]) {
  const queryRunner = this.dataSource.createQueryRunner();

  await queryRunner.connect();
  await queryRunner.startTransaction();
  try {
    await queryRunner.manager.save(users[0]);
    await queryRunner.manager.save(users[1]);

    await queryRunner.commitTransaction();
  } catch (err) {
    // since we have errors lets rollback the changes we made
    await queryRunner.rollbackTransaction();
  } finally {
    // you need to release a queryRunner which was manually instantiated
    await queryRunner.release();
  }
}`
# HINT
Note that the dataSource is used only to create the QueryRunner. However, to test this class would require mocking the entire DataSource object (which exposes several methods). Thus, we recommend using a helper factory class (e.g., QueryRunnerFactory) and defining an interface with a limited set of methods required to maintain transactions. This technique makes mocking these methods pretty straightforward.
Alternatively, you can use the callback-style approach with the transaction method of the DataSource object [read more](https://typeorm.io/#/transactions/creating-and-using-transactions).


`async createMany(users: User[]) {
  await this.dataSource.transaction(async manager => {
    await manager.save(users[0]);
    await manager.save(users[1]);
  });
}`

Transaction isolation levels 
- READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE
[cybertec](https://www.cybertec-postgresql.com/en/transactions-in-postgresql-read-committed-vs-repeatable-read/#:~:text=The%20REPEATABLE%20READ%20transaction%20will,while%20it%20is%20being%20modified.)


# Events 
Events are like Hooks in Sequelize .
Marks a class as an event subscriber which can listen to specific entity events or any entity events. Events are firing using QueryBuilder and repository/manager methods. 

so we can create an EventListener for a particular entity or any entity in the db 

to do this we create a class that  extends EntitySubscriberInterface 
Example:

`@EventSubscriber()
export class PostSubscriber implements EntitySubscriberInterface<Post> {
    /**
     * Indicates that this subscriber only listen to Post events.
     */
    listenTo() {
        return Post
    }

    /**
     * Called before post insertion.
     */
    beforeInsert(event: InsertEvent<Post>) {
        console.log(`BEFORE POST INSERTED: `, event.entity)
    }
}`

# Hint
You can implement any method from EntitySubscriberInterface. To listen to any entity you just omit listenTo method and use any:

`
@EventSubscriber()
export class PostSubscriber implements EntitySubscriberInterface {
    /**
     * Called after entity is loaded.
     */
    afterLoad(entity: any) {
        console.log(`AFTER ENTITY LOADED: `, entity)
    }

    /**
     * Called before post insertion.
     */
    beforeInsert(event: InsertEvent<any>) {
        console.log(`BEFORE POST INSERTED: `, event.entity)
    }

    /**
     * Called after entity insertion.
     */
    afterInsert(event: InsertEvent<any>) {
        console.log(`AFTER ENTITY INSERTED: `, event.entity)
    }

    /**
     * Called before entity update.
     */
    beforeUpdate(event: UpdateEvent<any>) {
        console.log(`BEFORE ENTITY UPDATED: `, event.entity)
    }

    /**
     * Called after entity update.
     */
    afterUpdate(event: UpdateEvent<any>) {
        console.log(`AFTER ENTITY UPDATED: `, event.entity)
    }

    /**
     * Called before entity removal.
     */
    beforeRemove(event: RemoveEvent<any>) {
        console.log(
            `BEFORE ENTITY WITH ID ${event.entityId} REMOVED: `,
            event.entity,
        )
    }

    /**
     * Called after entity removal.
     */
    afterRemove(event: RemoveEvent<any>) {
        console.log(
            `AFTER ENTITY WITH ID ${event.entityId} REMOVED: `,
            event.entity,
        )
    }

    /**
     * Called before entity removal.
     */
    beforeSoftRemove(event: SoftRemoveEvent<any>) {
        console.log(
            `BEFORE ENTITY WITH ID ${event.entityId} SOFT REMOVED: `,
            event.entity,
        )
    }

    /**
     * Called after entity removal.
     */
    afterSoftRemove(event: SoftRemoveEvent<any>) {
        console.log(
            `AFTER ENTITY WITH ID ${event.entityId} SOFT REMOVED: `,
            event.entity,
        )
    }

    /**
     * Called before entity recovery.
     */
    beforeRecover(event: RecoverEvent<any>) {
        console.log(
            `BEFORE ENTITY WITH ID ${event.entityId} RECOVERED: `,
            event.entity,
        )
    }

    /**
     * Called after entity recovery.
     */
    afterRecover(event: RecoverEvent<any>) {
        console.log(
            `AFTER ENTITY WITH ID ${event.entityId} RECOVERED: `,
            event.entity,
        )
    }

    /**
     * Called before transaction start.
     */
    beforeTransactionStart(event: TransactionStartEvent) {
        console.log(`BEFORE TRANSACTION STARTED: `, event)
    }

    /**
     * Called after transaction start.
     */
    afterTransactionStart(event: TransactionStartEvent) {
        console.log(`AFTER TRANSACTION STARTED: `, event)
    }

    /**
     * Called before transaction commit.
     */
    beforeTransactionCommit(event: TransactionCommitEvent) {
        console.log(`BEFORE TRANSACTION COMMITTED: `, event)
    }

    /**
     * Called after transaction commit.
     */
    afterTransactionCommit(event: TransactionCommitEvent) {
        console.log(`AFTER TRANSACTION COMMITTED: `, event)
    }

    /**
     * Called before transaction rollback.
     */
    beforeTransactionRollback(event: TransactionRollbackEvent) {
        console.log(`BEFORE TRANSACTION ROLLBACK: `, event)
    }

    /**
     * Called after transaction rollback.
     */
    afterTransactionRollback(event: TransactionRollbackEvent) {
        console.log(`AFTER TRANSACTION ROLLBACK: `, event)
    }
}`

# Common data source options

entities - Entities, or Entity Schemas, to be loaded and used for this data source. Accepts both entity classes, entity schema classes, and directories paths to load from. Directories support glob patterns. Example: entities: [Post, Category, "entity/*.js", "modules/**/entity/*.js"]. Learn more about Entities. Learn more about Entity Schemas.

subscribers - Subscribers to be loaded and used for this data source. Accepts both entity classes and directories to load from. Directories support glob patterns. Example: subscribers: [PostSubscriber, AppSubscriber, "subscriber/*.js", "modules/**/subscriber/*.js"]. Learn more about Subscribers.


# Subscribers
With TypeORM subscribers, you can listen to specific entity events.

add subscriber to datasource using
dataSource.subscribers.push(this)

- then listenTo fro listening to a particular entity

then define hook Methods in class .. that listen to events.
beforeInsert(event: InserEvent<User>){
     console.log(`BEFORE USER INSERTED: `, event.entity);
}

finally add subscriber to provider ðŸ˜Ž
`@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService, UserSubscriber],
  controllers: [UsersController],
})`


# TypeOrm Cli

add this  to your scripts in package.json
 "typeorm": "typeorm-ts-node-commonjs"


